---
layout: post
title: Các kỹ thuật về ảo hóa trong Cloud
date: 2015-06-01 19:51:01.000000000 +07:00
type: post
published: true
status: publish
categories:
- Khác
- Tài liệu tham khảo
tags: []
meta:
  _edit_last: '61498925'
  geo_public: '0'
  _publicize_job_id: '11235138156'
author:
  login: vnstack
  email: vietstack@gmail.com
  display_name: vietstack
  first_name: Viet
  last_name: Stack
---
<p class="western" align="justify"><span style="color:#222222;"><span style="font-family:serif;"><span style="font-size:medium;"><b><br />
HYPER-THREADING</b></span></span></span></p>
<p class="western" align="justify"><span style="color:#222222;"><span style="font-family:serif;"><span style="font-size:medium;"><span lang="en-US">Mặc dù công nghệ vi xử lý (micro processing) của các bộ xử lý trung tâm (CPU) đã đạt được những thành tựu vô cùng lớn trong thời gian gần đây nhưng vẫn tồn tại một vấn đề mà các vi xử lý gặp phải đó là một processor core đơn chỉ có thể thực hiện được một câu lệnh tại một thời điểm nhất định. Ví dụ nếu ta bật một lúc các chương trình như Google Chrome, Youtube, etc. với các processor hiện đại, quá trình thực hiện việc khởi động các chương trình diễn ra vô cùng nhanh, người dùng có cảm giác như multi-tasking, nhưng thực tế mỗi processor core thực hiện các tác vụ liên quan đến việc khởi động các chương trình này chỉ giải quyết một câu lệnh tại một thời điểm nhất định. Quá trình này cho dù diễn ra tương đối nhanh nhưng vẫn có thời gian trễ (delay). Độ lớn của delay phụ thuộc vào sự tương tác giữa các chương trình với CPU, thời gian để tải dữ liệu lên CPU, etc. Mỗi core của CPU sẽ phải lên kế hoạch (schedule) một thread, thực thi nhiệm vụ của thread đó một cách riêng biệt tại một thời điểm nhất định.</span></span></span></span></p>
<p class="western" align="justify"><span style="color:#222222;"><span style="font-family:serif;"><span style="font-size:medium;"><span lang="en-US">Hyper-threading -- một công nghệ phần cứng được “trademarked” và được Intel thực hiện trên các bộ vi xử lí của họ -- sẽ cho phép mỗi core schedule và thực thi 2 thread (có thể là nhiều hơn 2, nhưng thường là 2) tại một thời điểm nhất định. Với hyper-threading, số lượng cores của CPU sẽ được tăng lên gấp đôi. Ví dụ, nếu ta thấy số lượng CPU core là 4, thực ra chỉ có 2 physical CPU core. Tuy nhiên các hypervisor (KVM, Hyper-V, etc.) sẽ nhận ra 2 logical processor trên mỗi core, do đó số lượng của CPU core sẽ giống như gấp đôi so với physical CPU core. Ta có thể nhận thấy rõ ràng việc double core này nếu ta quan sát trong Task Manager. </span></span></span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"> Việc khai thác lợi thế của hyper-threading phụ thuộc khá nhiều vào cấu trúc của chương trình. Có những chương trình được viết không nhằm sử dụng multi-threading, do đó mặc dù tại một thời điểm có rất nhiều chương trình đang chạy nhưng chỉ có một CPU core đang hoạt động.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"> Hyper-threading sẽ thực sự hữu dụng và phát huy được khả năng nếu ta ứng dụng trong các ứng dụng nặng về video/audio coding, transcoding, </span></span><span style="font-family:serif;"><span style="font-size:medium;">các ứng dụng về khoa học được viết hoặc thiết kế với việc sử dụng multi-threading </span></span><span style="font-family:serif;"><span style="font-size:medium;">nhằm mục đích đạt được </span></span><span style="font-family:serif;"><span style="font-size:medium;">throughput cao. Hyper-threading không đảm bảo cho việc tăng hiệu năng hệ thống, thậm chí tác động mạnh theo chiều hướng ngược lại (e.g. các thread có thể sử dụng chung các resources, do đó làm giảm hiệu năng)</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"><b>HUGE PAGE:</b></span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"> Memory được quản lý trong các block dưới dạng là page. Mỗi page có kích cỡ chuẩn 4KB. CPU có một đơn vị quản lý bộ nhớ (MMU - Memory Management Unit) bao gồm 1 list các page, mỗi page được trỏ đến thông qua một page table entry. (&lt;-- có thể nên nói nhanh gọn về “memory page swapping”) </span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Việc quản lý số lượng page của hệ thống được diễn ra thông qua 2 phương pháp:</span></span></p>
<ul>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Tăng số lượng các page table entry trong MMU</span></span></li>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Tăng kích cỡ của page.</span></span></li>
</ul>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Phương pháp tăng số lượng các page table entry trong MMU phụ thuộc rất lớn vào sự phát triển của công nghệ vi xử lý - chip, tuy nhiên hiện nay, các MMU trong các chip hiện đại chỉ hỗ trợ khoảng hàng trăm đến hàng nghìn page table entry với chi phí rất cao. Ngoài ra, các thuật toán trong việc quản lý bộ nhớ và phần cứng hiện tại cũng chỉ hỗ trợ số lượng trăm, nghìn page table entry, tạo ra sự khó khăn nhất định với hàng triệu, thậm chí hàng tỷ page table entry.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Với sự phát triển vượt bậc của các ứng dụng hiện nay, có rất nhiều ứng dụng để đạt được hiệu quả cao trong</span></span> <span style="font-family:serif;"><span style="font-size:medium;">hiệu năng </span></span><span style="font-family:serif;"><span style="font-size:medium;">cần nhiều hơn số lượng page table entry trong MMU. Nếu MMU không đáp ứng được, hệ thống sẽ phản ứng rất chậm trong việc tương tác với ứng dụng. </span></span></p>
<p class="western" align="justify"><strong><span style="font-family:serif;"><span style="font-size:medium;">Tăng kích cỡ của page: </span></span></strong></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Kích cỡ của page sẽ được tăng lên với cấp số nhân của kích cỡ tiêu chuẩn (4KB) tùy thuộc vào mục đích sử dụng. Huge page có thể có kích cỡ từ 2MB tới hàng GB. </span></span></p>
<p class="western" align="justify"><span style="text-decoration:underline;"><span style="font-family:serif;"><span style="font-size:medium;">Ưu điểm: </span></span></span></p>
<ul>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Huge page được pin trực tiếp tới bộ nhớ, do đó nó không bị swap in/out từ RAM. Điều này làm giảm overhead cho quá trình paging, tăng hiệu năng của hệ thống.</span></span></li>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Huge page sẽ làm cho số lượng các page table entry giảm, TLB look ups sẽ hoạt động nhanh hơn trong việc tìm kiếm địa chỉ.</span></span></li>
</ul>
<p class="western" align="justify"><span style="text-decoration:underline;"><span style="font-family:serif;"><span style="font-size:medium;">Nhược điểm:</span></span></span></p>
<ul>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">RAM sẽ bị tiêu thụ và đầy rất nhanh nếu như không có quá trình swap. Việc sử dụng hugepage như thế nào cho hiệu quả tùy thuộc vào độ lớn ứng dụng, dịch vụ đang sử dụng. Ta có thể định nghĩa một phần RAM cho hugepage, số lượng RAM còn lại vẫn sử dụng page tiêu chuẩn.</span></span></li>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Hugepage chỉ nên được ứng dụng với các workload sử dụng trực tiếp không gian hugepage của RAM, tránh trường hợp fragmented memory.</span></span></li>
</ul>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"><b>NUMA:</b></span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">NUMA (Non-Uniform Memory Access) là một kiểu kiến trúc bộ nhớ máy tính nhằm hổ trợ cho hệ thống đa xử lý (multi processing) trong đó bộ nhớ (memory) thể hiện các đặc tính hiệu năng riêng biệt tại những điểm khác nhau trong không gian địa chỉ của CPU. </span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Để hiểu được NUMA, ta cần quay lại khái niệm về cấu trúc bộ nhớ chung (shared memory architecture). Cấu trúc này được chia làm 2 loại: Uniform Access Memory (UAM) và Non-Uniform Memory Access (NUMA). Với UAM, các CPU dùng bộ nhớ chung (shared memory). Để truy cập vào bộ nhớ này, CPU phải trải qua một quá trình khá phức tạp bao gồm giao tiếp với bộ điểu khiển I/O (I/O controller) thông qua bus. Bộ điều khiển này kết nối với Memory Controller - cấu trúc với chức năng như một hub kết nối với memory. Cấu trúc này có rất nhiều hạn chế về khả năng co giãn, latency hay băng thông. Ngoài ra CPU muốn kết nối với I/O controller phải chiếm được quyền kiểm soát bus tại một thời điểm nhất định (trong trường hợp multi-CPUs), điều này rất dễ gây ra vấn đề về tắc nghẽn trong truyền tải dữ liệu.</span></span></p>
<p class="western" align="justify"><a href="https://vietstack.files.wordpress.com/2015/06/numa.png"><img class="aligncenter size-full wp-image-488" src="{{ site.baseurl }}/assets/numa.png" alt="numa" width="630" height="215" /></a></p>
<p class="western" align="center"><span style="font-family:serif;"><span style="font-size:medium;">Source: www.db.inf.tu-dresden.de</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Để giải quyết các vấn đề về băng thông, tính co giãn hay latency, kỹ thuật NUMA được ra đời. Bản chất của NUMA chính là giảm khoảng cách giữa bộ nhớ và CPU dựa trên việc xác định vị trí của từng khu vực bộ nhớ theo độ dài đường tín hiệu (signal path lengh). Bằng phương pháp này, mỗi CPU sẽ được gán trực tiếp với một số lượng bộ nhớ nhất định (local memory). Bộ nhớ được kết nối với CPU khác được xem là bộ nhớ ở </span></span><span style="font-family:serif;"><span style="font-size:medium;">xa </span></span><span style="font-family:serif;"><span style="font-size:medium;">(remote memory). Việc kết nối giữa các CPU với nhau được gọi là inter-connection. Ví dụ CPU 1, CPU 2 đều có dung lượng bộ nhớ local là 2GB. Đối với CPU 1, 2GB bộ nhớ của CPU 2 được xem là remote memory. Việc truy cập vào remote memory cũng gây ra latency và overhead, do đó các tác vụ đều được ưu tiên sử dụng các local memory trước, sau đó là remote memory. Việc bộ nhớ được nằm rải rác về mặt hình học và sự truy cập dựa trên khoảng cách giữa local memory và remote memory được gọi là NUMA.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Quá trình ứng dụng kỹ thuật NUMA đòi hỏi sự hỗ trợ của </span></span><span style="font-family:serif;"><span style="font-size:medium;">hệ điều hành </span></span><span style="font-family:serif;"><span style="font-size:medium;">(operating system – OS). Nếu như OS hỗ trợ NUMA (NUMA phải được kích hoạt tại runtime và BIOS hoặc firmware phải xác nhận thông tin NUMA do đó NUMA có thể được điều khiển hay khởi động tại runtime với các thông số của kernel) thì ta có thể dễ dàng phân chia bộ nhớ dựa theo các ứng dụng một cách hiệu quả nhất nhằm đạt được kết quả cao về hiệu năng. Với một số ứng dụng cần hiệu năng cao, ta có thể sử dụng NUMA. Đối với những ứng dụng không đòi hỏi hiệu năng, ta vẫn </span></span><span style="font-family:serif;"><span style="font-size:medium;">có thể</span></span><span style="font-family:serif;"><span style="font-size:medium;"> sử dụng phương pháp truy cập và cấp phát bộ nhớ thông thường.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;"><b>SR-IOV (Single Root I/O Virtualization):</b></span></span></p>
<p class="western" align="justify"><a href="https://vietstack.files.wordpress.com/2015/06/a.jpg"><img class="aligncenter size-full wp-image-487" src="{{ site.baseurl }}/assets/a.jpg" alt="a" width="630" height="313" /></a></p>
<p class="western" align="center"><span style="font-family:serif;"><span style="font-size:medium;">Source: http://windowsitpro.com/virtualization/</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Việc tăng hiệu năng của CPU trong môi trường ảo hóa đã có những bước tiến vượt bậc với sự phát triển của công nghệ, tuy nhiên hiệu năng của các thiết bị I/O vẫn còn là dấu hỏi. Kỹ thuật về SR-IOV được ra đời trong những năm gần đây sử dụng sự hỗ trợ từ các chip của Intel@ hay AMD sẽ phần nào giải quyết vấn đề này.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Bản chất của khái niệm ảo hóa platform chính là việc chia sẻ platform giữa 2 hoặc nhiều OS để tận dụng hiệu quả các loại tài nguyên (resources). Khái niệm platform không chỉ dừng lại ở những bộ xử lí mà còn bao trùm toàn bộ các tài nguyên như lưu trữ, mạng, v. v. , trong đó một số các tài nguyên như serial port hay video card thì việc tăng hiệu năng dường như là bài toán khó trong ảo hóa. PCI passthrough cho phép ta giải quyết vấn đề này.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Device </span></span><span style="font-family:serif;"><span style="font-size:medium;">virtualization </span></span><span style="font-family:serif;"><span style="font-size:medium;">được phân chia thành 2 cấu trúc: Hypervisor-based device emulation và User space device emulation. Trong cấu trúc của Hypervisor-based device emulation, các emulated devices như ổ đĩa ảo, adapter mạng ảo, etc. được nằm trong hypervisor và được chia sẻ bởi rất nhiều các Guest OS. Trong khi đó, cấu trúc User space device emulation bao gồm các emulated devices nằm trong không gian người dùng (user space) thay vì hypervisor. Điều này sẽ làm cho cấu </span></span><span style="font-family:serif;"><span style="font-size:medium;">trúc </span></span><span style="font-family:serif;"><span style="font-size:medium;">user space device emula</span></span><span style="font-family:serif;"><span style="font-size:medium;">t</span></span><span style="font-family:serif;"><span style="font-size:medium;">ion có nhiều ưu điểm hơn bởi vì các emulated devices sẽ độc lập hoàn toàn với hypervisor của Host OS, </span></span><span style="font-family:serif;"><span style="font-size:medium;">tránh việc </span></span><span style="font-family:serif;"><span style="font-size:medium;">ảnh hưởng trực tiếp đến khả năng bảo mật của Host hypervisor. </span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Cho dù ảo hóa mang lại nhiều lợi ích, nhưng đồng thời vẫn tồn tại overhead trong hệ thống ảo hóa. Càng nhiều Guest OS sử dụng chung các tài nguyên thì overhead càng cao. Passthrough là phương pháp làm giảm overhead với mục đích làm tăng hiệu năng cho một số nhóm Guest OS nhất định. Device passthrough cho phép các devices được kết nối trực tiếp với Guest OS mà không phải thông qua Host OS. Quá trình giao tiếp của devices với Guest OS thông qua Host OS mang lại rất nhiều overhead khi mà phải đi qua các driver trong Host hypervisor. Ngoài ra, có một số devices không có khả năng chia sẻ </span></span><span style="font-family:serif;"><span style="font-size:medium;">resource</span></span><span style="font-family:serif;"><span style="font-size:medium;">, do vậy việc tách biệt các device này dàn</span></span><span style="font-family:serif;"><span style="font-size:medium;">h</span></span><span style="font-family:serif;"><span style="font-size:medium;"> riêng cho một nhóm Guest OS cụ thể là vô cùng cần thiết.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Tuy nhiên, giải pháp PCI passthough sẽ gặp phải vấn đề trong việc live-migration. Để physical devices có thể giao tiếp với các hypervisors của Guest OS, </span></span><span style="font-family:serif;"><span style="font-size:medium;">PCI hotplug driver (</span></span><span style="font-family:serif;"><span style="font-size:medium;">PCI hotplug driver là một tính năng được chuẩn hóa trong GNU/Linux từ kernel 2.4, cho phép thực việc các tác vụ đối với PCI device như insert/replace etc. mà không cần tắt nguồn hệ thống</span></span><span style="font-family:serif;"><span style="font-size:medium;">) </span></span><span style="font-family:serif;"><span style="font-size:medium;">cho phép các devices đi qua kernel của Host OS và kết nối tới hypervisor của Guest OS. Trong quá trinh live-migration, các devices phải được unplug từ Guest hypervisor cũ và sau đó plug in vào Guest hypervisor mới. Điều này vô cùng phức tạp nếu so sánh với phương pháp ảo hóa trong đó quá trình emulation cung cấp một tầng trừu tương (abstract layer) cho phép ta dễ dàng live-migrate các Guest machine.</span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Giải pháp hiện nay cho việc ảo hóa I/O chính là SR-IOV (Single-root I/O virtualization), được PCI-SIG (PCI-Special Interest Group) định nghĩa. Với sự hỗ trợ của SR-IOV ta có thể đạt được băng thông 10G Ethernet trong việc ứng dụng NFV (Network Function Virtualization). Ý tưởng của SR-IOV chính là việc replicate các resource của devices (các devices sẽ được nhóm thành các thực thể) để cung cấp các stream về ngắt, DMA (Direct Memory Access), không gian bộ nhớ cho từng máy ảo một cách riêng rẽ. Do đó, máy ảo có thể sử dụng trực tiếp các devices, dữ liệu có thể truyền giữa máy ảo và host mà không cần sự can thiệp của hypervisor. </span></span></p>
<p class="western" align="justify"><span style="font-family:serif;"><span style="font-size:medium;">Trong giải pháp SR-IOV, khái niệm VF (Virtual Function) được xuất hiện. VF là những thực thể PCI 'lightweight' bao gồm các resources cần thiết cho việc truyền dữ liệu giữa các máy ảo và devices. Trong mô hình này, passthrough sẽ không cần thiết bởi vì sự ảo hóa diễn ra tại các device cho phép hypervisor (thực chất là VMM - Virtual Machine Manager nằm trong hypervisor) map các VF tới không gian cấu hình (configuration space) của máy ảo. Việc mapping trực tiếp sẽ đem lại hiệu năng cao, giải quyết các vấn đề về bảo mật hoặc tính cô lập (isolation). </span></span></p>
<p class="western" align="justify"><span style="text-decoration:underline;"><span style="font-family:serif;"><span style="font-size:medium;">Các ưu điểm của SR-IOV:</span></span></span></p>
<ul>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Số lượng ngắt tham gia trong qúa trình truyền dữ liệu ít đi.</span></span></li>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">Không cần sự can thiệp của hypervisor, giảm thiểu các overhead.</span></span></li>
<li class="western"><span style="font-family:serif;"><span style="font-size:medium;">DMA tới không gian bộ nhớ của máy ảo.</span></span></li>
</ul>
<p>&nbsp;</p>
<p>1-6-2015</p>
<p>Vietstack Team</p>
